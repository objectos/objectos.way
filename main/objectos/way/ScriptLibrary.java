/*
 * Copyright (C) 2023-2025 Objectos Software LTDA.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package objectos.way;

import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;

/*
 * Do not edit: this class was generated by ScriptLibraryGen.java.
 */
enum ScriptLibrary implements Script.Library {

  INSTANCE;

  @Override
  public final String contentType() {
    return "text/javascript; charset=utf-8";
  }

  @Override
  public final Charset charset() {
    return StandardCharsets.UTF_8;
  }

  @Override
  public final void writeTo(Appendable out) throws IOException {
    out.append(toString());
  }

  @Override
  public final String toString() {
    return """
/*
 * Copyright (C) 2023-2025 Objectos Software LTDA.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const way = (function() {

  "use strict";

  const way = {

    config: {

      errorHandler: function(error) {
        throw error;
      },

      history: true

    }

  };

  // ##################################################################
  // # BEGIN: DOM Event Handlers
  // ##################################################################

  function clickListener(event) {
    let el = event.target;

    while (el instanceof Node) {
      const result = executeEvent(el, "onClick");

      if (result) {
        event.preventDefault();

        break;
      }

      // there was no data-on-click action...
      // but we explicitly stop at these elements

      if (el instanceof HTMLAnchorElement) {
        break;
      }

      if (el instanceof HTMLButtonElement) {
        break;
      }

      // continue with this element's parent

      el = el.parentNode;
    }
  }

  function executeEvent(el, name) {
    const dataset = el.dataset;

    if (!dataset) {
      return false;
    }

    const data = dataset[name];

    if (!data) {
      return false;
    }

    const way = JSON.parse(data);

    executeWay(el, way);

    return true;
  }

  // ##################################################################
  // # END: DOM Event Handlers
  // ##################################################################

  // ##################################################################
  // # BEGIN: Objectos Way Actions
  // ##################################################################

  const actionHandlers = {
    "CR": contextRead,
    "CW": contextWrite,
    "IV": invokeVirtual,
    "LO": locate,
    "PR": propertyRead,
    "PW": propertyWrite
  };

  function executeWay(el, way) {
    checkArray(way, "way");

    const ctx = {
      el: el
    };

    for (const actions of way) {
      executeWay0(ctx, actions);
    }

    return true;
  }

  function executeWay0(ctx, actions) {
    checkArray(actions, "actions");

    let recv = null;

    for (const action of actions) {
      ctx.recv = recv;

      recv = executeWay1(ctx, action);
    }

    return recv;
  }

  function executeWay1(ctx, action) {
    checkArray(action, "action");

    const key = checkString(action.shift(), "key");

    const handler = actionHandlers[key];

    if (handler) {
      return handler(ctx, action);
    } else {
      throw new Error(`Illegal arg: no action handler for key=${key}`);
    }
  }

  function arg(ctx, arg) {
    checkArray(arg, "arg");

    const kind = checkString(arg.shift(), "kind");

    switch (kind) {
      case "JS":
        return arg.shift();

      case "WA":
        const actions = arg.shift();

        return executeWay0(ctx, actions);

      default:
        throw new Error(`Illegal arg: unknown arg kind=${kind}`);
    }
  }

  function contextRead(ctx, args) {
    const store = ctx.store;

    if (!store) {
      return undefined;
    }

    const name = checkString(args.shift(), "name");

    return store[name];
  }

  function contextWrite(ctx, args) {
    let store = ctx.store;

    if (!store) {
      store = {};

      ctx.store = store;
    }

    const name = checkString(args.shift(), "name");

    const val = checkDefined(args.shift(), "value");

    store[name] = arg(ctx, val);
  }

  function invokeVirtual(ctx, args) {
    const typeName = checkString(args.shift(), "typeName");

    const recv = ctx.recv;

    checkType(recv, "recv", typeName);

    const methodName = checkString(args.shift(), "methodName");

    const method = recv[methodName];

    if (!method) {
      throw new Error(`Illegal arg: ${typeName} does not declare the ${methodName} method`);
    }

    const encodedArgs = checkArray(args.shift(), "encodedArgs");

    const methodArgs = encodedArgs.map(x => arg(ctx, x));

    return method.call(recv, methodArgs);
  }

  function locate(ctx, args) {
    const kind = checkString(args.shift(), "kind");

    switch (kind) {
      case "ID":
        const id = checkString(args.shift(), "id");

        const element = document.getElementById(id);

        if (!element) {
          throw new Error(`Illegal arg: element not found with ID ${id}`);
        }

        return element;

      case "TT":
        return ctx.el;

      default:
        throw new Error(`Illegal arg: unknown locate kind=${kind}`);
    }
  }

  function propertyRead(ctx, args) {
    const typeName = checkString(args.shift(), "typeName");

    const recv = ctx.recv;

    checkType(recv, "recv", typeName);

    const propName = checkString(args.shift(), "propName");

    const prop = recv[propName];

    if (!prop) {
      throw new Error(`Illegal arg: ${typeName} does not declare the ${propName} property`);
    }

    return prop;
  }

  function propertyWrite(ctx, args) {
    const typeName = checkString(args.shift(), "typeName");

    const recv = ctx.recv;

    checkType(recv, "recv", typeName);

    const propName = checkString(args.shift(), "propName");

    const val = checkDefined(args.shift(), "value");

    recv[propName] = arg(ctx, val);
  }

  // ##################################################################
  // # END: Objectos Way Actions
  // ##################################################################

  // ##################################################################
  // # BEGIN: private private
  // ##################################################################

  function checkArray(maybe, name) {
    if (!Array.isArray(maybe)) {
      throw new Error(`Illegal arg: ${name} must be an Array value but got ${maybe}`);
    }

    return maybe;
  }

  function checkDefined(maybe, name) {
    if (!maybe) {
      throw new Error(`Illegal arg: ${name} must be a defined value`);
    }

    return maybe;
  }

  function checkType(maybe, name, typeName) {
    const t = typeof maybe;

    if (t !== "object") {
      throw new Error(`Illegal arg: ${name} must be an Object value but got ${t}`);
    }

    let prototype = Object.getPrototypeOf(maybe);

    while (prototype) {
      const constructor = prototype.constructor;

      if (!constructor) {
        throw new Error(`Illegal arg: expected ${name} to have a constructor, but found ${constructor}`);
      }

      const actualName = constructor.name;

      if (actualName === typeName) {
        return maybe;
      }

      prototype = Object.getPrototypeOf(prototype);
    }

    throw new Error(`Illegal arg: ${name} does not have ${typeName} in its prototype chain`);
  }

  function checkString(maybe, name) {
    const t = typeof maybe;

    if (t !== "string") {
      throw new Error(`Illegal arg: ${name} must be a String value but got ${t}`);
    }

    return maybe;
  }

  // ##################################################################
  // # END: private private
  // ##################################################################

  // ##################################################################
  // # BEGIN: Objectos Way Bootstrap
  // ##################################################################

  function listener(actual) {
    return function(event) {
      try {
        actual.call(this, event)
      } catch (error) {
        way.config.errorHandler(error);
      }
    };
  }

  function domLoaded() {
    document.addEventListener("click", listener(clickListener));
  }

  window.addEventListener("DOMContentLoaded", domLoaded);

  // ##################################################################
  // # END: Objectos Way Bootstrap
  // ##################################################################

  return way;

})();
""";
  }

}
